![visitors](https://visitor-badge.glitch.me/badge?page_id=linaqruf.lora-dreambooth) [![](https://dcbadge.vercel.app/api/shield/931591564424253512?style=flat)](https://lookup.guru/931591564424253512) [![ko-fi](https://img.shields.io/badge/Support%20me%20on%20Ko--fi-F16061?logo=ko-fi&logoColor=white&style=flat)](https://ko-fi.com/linaqruf) <a href="https://saweria.co/linaqruf"><img alt="Saweria" src="https://img.shields.io/badge/Saweria-7B3F00?style=flat&logo=ko-fi&logoColor=white"/></a>

# Kohya LoRA Dreambooth<br><small><small>A Colab Notebook For LoRA Training (Dreambooth Method)</small></small>


| Notebook Name | Description | Link |
| --- | --- | --- |
| [Kohya LoRA Dreambooth](https://github.com/Linaqruf/kohya-trainer/blob/main/kohya-LoRA-dreambooth.ipynb) | LoRA Training (Dreambooth method) | [![](https://img.shields.io/static/v1?message=Open%20in%20Colab&logo=googlecolab&labelColor=5c5c5c&color=0f80c1&label=%20&style=for-the-badge)](https://colab.research.google.com/github/Linaqruf/kohya-trainer/blob/main/kohya-LoRA-dreambooth.ipynb) |
| [Kohya LoRA Fine-Tuning](https://github.com/Linaqruf/kohya-trainer/blob/main/kohya-LoRA-finetuner.ipynb) | LoRA Training (Fine-tune method) | [![](https://img.shields.io/static/v1?message=Open%20in%20Colab&logo=googlecolab&labelColor=5c5c5c&color=0f80c1&label=%20&style=for-the-badge)](https://colab.research.google.com/github/Linaqruf/kohya-trainer/blob/main/kohya-LoRA-finetuner.ipynb) |
| [Kohya Trainer](https://github.com/Linaqruf/kohya-trainer/blob/main/kohya-trainer.ipynb) | Native Training | [![](https://img.shields.io/static/v1?message=Open%20in%20Colab&logo=googlecolab&labelColor=5c5c5c&color=0f80c1&label=%20&style=for-the-badge)](https://colab.research.google.com/github/Linaqruf/kohya-trainer/blob/main/kohya-trainer.ipynb) |
| [Kohya Dreambooth](https://github.com/Linaqruf/kohya-trainer/blob/main/kohya-dreambooth.ipynb) | Dreambooth Training | [![](https://img.shields.io/static/v1?message=Open%20in%20Colab&logo=googlecolab&labelColor=5c5c5c&color=0f80c1&label=%20&style=for-the-badge)](https://colab.research.google.com/github/Linaqruf/kohya-trainer/blob/main/kohya-dreambooth.ipynb) |
| [Fast Kohya Trainer](https://github.com/Linaqruf/kohya-trainer/blob/main/fast-kohya-trainer.ipynb) `NEW`| Easy 1-click LoRA & Native Training| [![](https://img.shields.io/static/v1?message=Open%20in%20Colab&logo=googlecolab&labelColor=5c5c5c&color=0f80c1&label=%20&style=for-the-badge)](https://colab.research.google.com/github/Linaqruf/kohya-trainer/blob/main/fast-kohya-trainer.ipynb) |
| [Cagliostro Colab UI](https://github.com/Linaqruf/sd-notebook-collection/blob/main/cagliostro-colab-ui.ipynb) `NEW`| A Customizable Stable Diffusion Web UI| [![](https://img.shields.io/static/v1?message=Open%20in%20Colab&logo=googlecolab&labelColor=5c5c5c&color=0f80c1&label=%20&style=for-the-badge)](https://colab.research.google.com/github/Linaqruf/sd-notebook-collection/blob/main/cagliostro-colab-ui.ipynb) |

# I. Install Kohya Trainer
#@title ## 1.1. Install Dependencies
#@markdown Clone Kohya Trainer from GitHub and check for updates. Use textbox below if you want to checkout other branch or old commit. Leave it empty to stay the HEAD on main.  This will also install the required libraries.
import os
import zipfile
import shutil
from subprocess import getoutput
from IPython.utils import capture
from google.colab import drive
%store -r

!nvidia-smi

#root_dir
root_dir = "/content"
deps_dir = os.path.join(root_dir,"deps")
repo_dir = os.path.join(root_dir,"kohya-trainer")
training_dir = os.path.join(root_dir,"LoRA")
pretrained_model = os.path.join(root_dir,"pretrained_model")
vae_dir = os.path.join(root_dir,"vae")

#repo_dir
accelerate_config = os.path.join(repo_dir, "accelerate_config/config.yaml")
tools_dir = os.path.join(repo_dir,"tools")
finetune_dir = os.path.join(repo_dir,"finetune")

for store in ["root_dir", "deps_dir", "repo_dir", "training_dir", "pretrained_model", "vae_dir", "accelerate_config", "tools_dir", "finetune_dir"]:
  with capture.capture_output() as cap:
    %store {store}
    del cap

branch = "" #@param {type: "string"}
install_xformers = True #@param {'type':'boolean'}
mount_drive = True #@param {type: "boolean"}

#@markdown Check this box if you want to clone the main repo instead to try new args or getting tired of waiting the forked repo to be updated.
clone_sd_scripts = False #@param {'type':'boolean'}

if not clone_sd_scripts:
  repo_url = "https://github.com/Linaqruf/kohya-trainer"
else:
  repo_url = "https://github.com/kohya-ss/sd-scripts"
  

if mount_drive:
  if not os.path.exists('/content/drive'):
    drive.mount('/content/drive')

for dir in [deps_dir, training_dir, pretrained_model, vae_dir]:
  os.makedirs(dir, exist_ok=True)
  
def clone_repo(url):
  if not os.path.exists(repo_dir):
    os.chdir(root_dir)
    !git clone {url} {repo_dir}
  else:
    os.chdir(repo_dir)
    !git pull origin {branch} if branch else !git pull

clone_repo(repo_url)

if branch:
  os.chdir(repo_dir)
  status = os.system(f"git checkout {branch}")
  if status != 0:
    raise Exception("Failed to checkout branch or commit")

os.chdir(repo_dir)

def ubuntu_deps(url, name, dst):
  with capture.capture_output() as cap:
    !wget -q --show-progress {url}
    with zipfile.ZipFile(name, 'r') as deps:
      deps.extractall(dst)
    !dpkg -i {dst}/*
    os.remove(name)
    shutil.rmtree(dst)
    del cap 

def install_dependencies():
  !pip -q install --upgrade gallery-dl gdown imjoy-elfinder
  !pip -q install --upgrade -r requirements.txt

  s = getoutput('nvidia-smi')
  if install_xformers:
    if 'T4' in s:
      %pip -q install https://github.com/camenduru/stable-diffusion-webui-colab/releases/download/0.0.16/xformers-0.0.16+814314d.d20230118-cp38-cp38-linux_x86_64.whl
      !pip -q install --pre triton
    if 'A100' in s:
      %pip -q install https://github.com/camenduru/stable-diffusion-webui-colab/releases/download/0.0.15/xformers-0.0.15+e163309.d20230103.ColabProA100-cp38-cp38-linux_x86_64.whl

  from accelerate.utils import write_basic_config
  if not os.path.exists(accelerate_config):
    write_basic_config(save_location=accelerate_config)

os.chdir(repo_dir)
ubuntu_deps("https://huggingface.co/Linaqruf/fast-repo/resolve/main/deb-libs.zip", "deb-libs.zip", deps_dir)
install_dependencies()


from google.colab import drive
drive.mount('/content/drive')
#@title ## 1.2. Open Special `File Explorer` for Colab (Optional)
#@markdown This will work in real-time even when you run other cells
import threading
from google.colab import output
from imjoy_elfinder.app import main
%store -r

thread = threading.Thread(target=main, args=[["--root-dir=/content", "--port=8765"]])
thread.start()

open_in_new_tab = True #@param {type:"boolean"}

if open_in_new_tab:
  output.serve_kernel_port_as_window(8765)
else:
  output.serve_kernel_port_as_iframe(8765, height='500')

# II. Pretrained Model Selection
#@title ## 2.1. Download Available Model 
import os
%store -r

os.chdir(root_dir)

installModels = []
installv2Models = []

#@markdown ### SD1.x model
modelUrl = ["",
            "https://huggingface.co/Linaqruf/personal-backup/resolve/main/models/animefull-final-pruned.ckpt",
            "https://huggingface.co/cag/anything-v3-1/resolve/main/anything-v3-1.safetensors",
            "https://huggingface.co/cag/anything-v3-3/resolve/main/anything-v3-3.safetensors",
            "https://huggingface.co/andite/anything-v4.0/resolve/main/anything-v4.5-pruned.ckpt",
            "https://huggingface.co/Linaqruf/stolen/resolve/main/pruned-models/chillout_mix-pruned.safetensors",
            "https://huggingface.co/Linaqruf/stolen/resolve/main/pruned-models/Counterfeit-V2-5-pruned.safetensors",
            "https://huggingface.co/prompthero/openjourney-v2/resolve/main/openjourney-v2.ckpt",
            "https://huggingface.co/Linaqruf/stolen/resolve/main/pruned-models/stable_diffusion_1_5-pruned.safetensors"]
modelList = ["",
             "Animefull-final-pruned",
             "Anything-v3-1",
             "Anything-v3-3",
             "Anything-v4-5",
             "Chillout-mix",
             "Counterfeit-v2-5",
             "OpenJourney-v2",
             "Stable-Diffusion-v1-5"]
modelName = "Stable-Diffusion-v1-5"  #@param ["", "Animefull-final-pruned", "Anything-v3-1", "Anything-v3-3", "Anything-v4-5", "Chillout-mix", "Counterfeit-v2-5", "OpenJourney-v2", "Stable-Diffusion-v1-5"]

#@markdown ### SD2.x model
v2ModelUrl = ["",
              "https://huggingface.co/stabilityai/stable-diffusion-2-1-base/resolve/main/v2-1_512-ema-pruned.safetensors",
              "https://huggingface.co/stabilityai/stable-diffusion-2-1/resolve/main/v2-1_768-ema-pruned.safetensors",
              "https://huggingface.co/p1atdev/pd-archive/resolve/main/plat-v1-3-1.safetensors",
              "https://huggingface.co/gsdf/Replicant-V1.0/resolve/main/Replicant-V1.0.safetensors",
              "https://huggingface.co/IlluminatiAI/Illuminati_Diffusion_v1.0/resolve/main/illuminati_diffusion_v1.0.safetensors",
              "https://huggingface.co/hakurei/waifu-diffusion-v1-4/resolve/main/wd-1-4-anime_e2.ckpt",
              "https://huggingface.co/waifu-diffusion/wd-1-5-beta/resolve/main/checkpoints/wd15-beta1-fp32.safetensors"]
v2ModelList = ["",
              "stable-diffusion-2-1-base",
              "stable-diffusion-2-1-768v",
              "plat-diffusion-v1-3-1",
              "replicant-v1",
              "illuminati-diffusion-v1-768v",
              "waifu-diffusion-1-4-anime-e2",
              "waifu-diffusion-1-5-768v-e1"]
v2ModelName = "" #@param ["", "stable-diffusion-2-1-base", "stable-diffusion-2-1-768v", "plat-diffusion-v1-3-1", "replicant-v1", "illuminati-diffusion-v1-768v", "waifu-diffusion-1-4-anime-e2", "waifu-diffusion-1-5-768v-e1"]

if modelName:
  installModels.append((modelName, modelUrl[modelList.index(modelName)]))
if v2ModelName:
  installv2Models.append((v2ModelName, v2ModelUrl[v2ModelList.index(v2ModelName)]))

def install(checkpoint_name, url):
  ext = "ckpt" if url.endswith(".ckpt") else "safetensors"

  hf_token = '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' 
  user_header = f"\"Authorization: Bearer {hf_token}\""
  !aria2c --console-log-level=error --summary-interval=10 --header={user_header} -c -x 16 -k 1M -s 16 -d {pretrained_model} -o {checkpoint_name}.{ext} "{url}"

def install_checkpoint():
  for model in installModels:
    install(model[0], model[1])
  for v2model in installv2Models:
    install(v2model[0], v2model[1])

install_checkpoint()
#@title ## 2.2. Download Custom Model
import os
%store -r

os.chdir(root_dir)

#@markdown ### Custom model
modelUrl = "" #@param {'type': 'string'}

def install(url):
  base_name = os.path.basename(url)

  if url.startswith("https://drive.google.com"):
    os.chdir(pretrained_model)
    !gdown --fuzzy {url}
  elif url.startswith("https://huggingface.co/"):
    if '/blob/' in url:
      url = url.replace('/blob/', '/resolve/')
    #@markdown Change this part with your own huggingface token if you need to download your private model
    hf_token = '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' #@param {type:"string"}
    user_header = f"\"Authorization: Bearer {hf_token}\""
    !aria2c --console-log-level=error --summary-interval=10 --header={user_header} -c -x 16 -k 1M -s 16 -d {pretrained_model} -o {base_name} {url}
  else:
    !aria2c --console-log-level=error --summary-interval=10 -c -x 16 -k 1M -s 16 -d {pretrained_model} {url}

install(modelUrl)

#@title ## 2.3. Download Available VAE (Optional)
import os
%store -r 

os.chdir(root_dir)

installVae = []
#@markdown Select one of the VAEs to download, select `none` for not download VAE:
vaeUrl = ["",
          "https://huggingface.co/Linaqruf/personal-backup/resolve/main/vae/animevae.pt",
          "https://huggingface.co/hakurei/waifu-diffusion-v1-4/resolve/main/vae/kl-f8-anime.ckpt",
          "https://huggingface.co/stabilityai/sd-vae-ft-mse-original/resolve/main/vae-ft-mse-840000-ema-pruned.ckpt"]
vaeList = ["none",
           "anime.vae.pt",
           "waifudiffusion.vae.pt",
           "stablediffusion.vae.pt"]
vaeName = "stablediffusion.vae.pt" #@param ["none", "anime.vae.pt", "waifudiffusion.vae.pt", "stablediffusion.vae.pt"]

installVae.append((vaeName, vaeUrl[vaeList.index(vaeName)]))

def install(vae_name, url):
  hf_token = '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'
  user_header = f"\"Authorization: Bearer {hf_token}\""
  !aria2c --console-log-level=error --summary-interval=10 --header={user_header} -c -x 16 -k 1M -s 16 -d {vae_dir} -o {vae_name} "{url}"

def install_vae():
  if vaeName != "none":
    for vae in installVae:
      install(vae[0], vae[1])
  else:
    pass

install_vae()
# III. Data Acquisition

You have two options for acquiring your dataset: uploading it to this notebook or bulk downloading images from Danbooru using the image scraper. If you prefer to use your own dataset, simply upload it to Colab's local files.

#@title ## 3.1. Locating Train Data Directory
#@markdown Define the location of your training data. This cell will also create a folder based on your input. Leave `reg_data_dir` empty for now.
import os
%store -r

parent_directory = "/content/LoRA/train_data" #@param {type: "string"}
%store parent_directory
reg_folder_directory = os.path.join(os.path.dirname(parent_directory), "reg_data")
%store reg_folder_directory

reg_repeats = 1 #@param {type: "integer"}
train_repeats = 10 #@param {type: "integer"}
concept_name = "lartiguephoto" #@param {type: "string"}
class_name = "photography style" #@param {type: "string"}
#@markdown You can run this cell multiple time to add new concepts

def get_folder_name(repeats, class_name, concept_name=None):
  if class_name:
    return f"{repeats}_{concept_name} {class_name}" if concept_name else f"{repeats}_{class_name}"
  return f"{repeats}_{concept_name}"

train_folder = get_folder_name(train_repeats, class_name, concept_name=concept_name)
reg_folder = get_folder_name(reg_repeats, class_name)

train_data_dir = os.path.join(parent_directory, train_folder)
reg_data_dir = os.path.join(reg_folder_directory, reg_folder)

for dataset_dir in [parent_directory, reg_folder_directory, train_data_dir, reg_data_dir]:
  os.makedirs(dataset_dir, exist_ok=True)


#@title ## 3.2. Unzip Dataset
import os
import shutil
from pathlib import Path
%store -r

#@markdown Specify this section if your dataset is in a `zip` file and has been uploaded somewhere. This will download your dataset and automatically extract it to the `train_data_dir` if the `unzip_to` is empty. 
zipfile_url = "" #@param {'type': 'string'}
zipfile_name = "zipfile.zip"
unzip_to = "" #@param {'type': 'string'}

hf_token = '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'
user_header = f"\"Authorization: Bearer {hf_token}\""

if unzip_to:
  os.makedirs(unzip_to, exist_ok=True)
else:
  unzip_to = train_data_dir

def download_dataset(url):
  if url.startswith("/content"):
    !unzip -j -o {url} -d "{train_data_dir}"
  elif url.startswith("https://drive.google.com"):
    os.chdir(root_dir)
    !gdown --fuzzy {url}
  elif url.startswith("https://huggingface.co/"):
    if '/blob/' in url:
      url = url.replace('/blob/', '/resolve/')
    !aria2c --console-log-level=error --summary-interval=10 --header={user_header} -c -x 16 -k 1M -s 16 -d {root_dir} -o {zipfile_name} {url}
  else:
    !aria2c --console-log-level=error --summary-interval=10 -c -x 16 -k 1M -s 16 -d {root_dir} -o {zipfile_name} {url}

download_dataset(zipfile_url)

os.chdir(root_dir)

if not zipfile_url.startswith("/content"):
  !unzip -j -o "{root_dir}/{zipfile_name}" -d "{unzip_to}"
  os.remove(f"{root_dir}/{zipfile_name}")

files_to_move = ("meta_cap.json", \
                 "meta_cap_dd.json", \
                 "meta_lat.json", \
                 "meta_clean.json")

for filename in os.listdir(train_data_dir):
  file_path = os.path.join(train_data_dir, filename)
  if filename in files_to_move:
    if not os.path.exists(file_path):
      shutil.move(file_path, training_dir)
    else: 
      os.remove(file_path)
#@title ## 3.3. Image Scraper (Optional)
import os
import html
from IPython.utils import capture
%store -r

os.chdir(root_dir)
#@markdown Use gallery-dl to scrape images from a booru site using the specified tags
booru = "Danbooru" #@param ["Danbooru", "Gelbooru", "Safebooru"]
tag1 = "" #@param {type: "string"}
tag2 = "" #@param {type: "string"}
#@markdown This will ignore download configuration above.
custom_url = "" #@param {type: "string"}
#@markdown Other Config
user_agent = "gdl/1.24.5" #@param {type: "string"}
limit_rate = "" #@param {type: "string"}
write_tags = True #@param {type: "boolean"}
additional_arguments = "--filename /O --no-part" #@param {type: "string"}

#@markdown **Experimental**: Parallel Download with `aria2c`, fast, but ignoring `write-tags`. Not a wrapper, just a simple code to extract url from `gallery-dl` and download them using `aria2c`.
with_aria_2c = False #@param {type: "boolean"}

tags = tag1 if not tag2 else tag1 + "+" + tag2

tags = tags.replace("(", "%28")
tags = tags.replace(")", "%29")

if booru == "Danbooru":
  url = "https://danbooru.donmai.us/posts?tags={}".format(tags)
elif booru == "Gelbooru":
  url = "https://gelbooru.com/index.php?page=post&s=list&tags={}".format(tags)
else:
  url = "https://safebooru.org/index.php?page=post&s=list&tags={}".format(tags)

if with_aria_2c:
  scraper_text = os.path.join(root_dir, "scrape_this.txt")
  with capture.capture_output() as cap:
    !gallery-dl {custom_url if custom_url else url} \
      --get-urls \
      {"--limit_rate" if limit_rate else ""} \
      {"--user-agent " + user_agent if user_agent else ""} \
      {additional_arguments}
  with open(scraper_text, "w") as f:
    f.write(cap.stdout)

  os.chdir(train_data_dir)
  !aria2c --console-log-level=error --summary-interval=10 -c -x 16 -k 1M -s 16 -i {scraper_text}

else:
  !gallery-dl {custom_url if custom_url else url} \
    --directory "{train_data_dir}" \
    {"--write-tags" if write_tags else ""} \
    {"--limit_rate" if limit_rate else ""} \
    {"--user-agent " + user_agent if user_agent else ""} \
    {additional_arguments}

if write_tags: 
  files = [f for f in os.listdir(train_data_dir) if f.endswith(".txt")]

  for file in files:
    old_path = os.path.join(train_data_dir, file)
    new_file_name = os.path.splitext(os.path.splitext(file)[0])[0] + ".txt"
    new_path = os.path.join(train_data_dir, new_file_name)

    os.rename(old_path, new_path)

    with open(new_path, "r") as f:
      contents = f.read()

    contents = html.unescape(contents)
    contents = contents.replace("_", " ")
    contents = ", ".join(contents.split("\n"))

    with open(new_path, "w") as f:
      f.write(contents)

# IV. Data Preprocessing
#@title ## 4.1. Data Cleaning
#@markdown ### Delete Unnecessary Files
import os
import random
import concurrent.futures
from tqdm import tqdm
from PIL import Image
%store -r

os.chdir(root_dir)

test = os.listdir(train_data_dir)
#@markdown This section will delete unnecessary files and unsupported media such as `.mp4`, `.webm`, and `.gif`. 
#@markdown By default, it keeps metadata files (`.npz`, `.txt`, `.caption`, and `.json`), but you can exclude them from the supported types.
delete_metadata = True #@param {'type':'boolean'}

if not delete_metadata:
  supported_types = [".png", ".jpg", ".jpeg", ".webp", ".bmp", ".caption", ".npz", ".txt", ".json"]
else:
  supported_types = [".png", ".jpg", ".jpeg", ".webp", ".bmp"]

for item in test:
    file_ext = os.path.splitext(item)[1]
    if file_ext not in supported_types:
        print(f"Deleting file {item} from {train_data_dir}")
        os.remove(os.path.join(train_data_dir, item))

#@markdown ### <br> Convert Transparent Images
#@markdown This code will convert your transparent dataset with alpha channel (RGBA) to RGB and give it a white background. 

convert = True #@param {type:"boolean"}
random_color = False #@param {type:"boolean"}

batch_size = 32

images = [image for image in os.listdir(train_data_dir) if image.endswith('.png') or image.endswith('.webp')]
background_colors = [(255, 255, 255), 
                     (0, 0, 0), 
                     (255, 0, 0), 
                     (0, 255, 0), 
                     (0, 0, 255), 
                     (255, 255, 0), 
                     (255, 0, 255), 
                     (0, 255, 255)]

def process_image(image_name):
    img = Image.open(f'{train_data_dir}/{image_name}')

    if img.mode in ('RGBA', 'LA'):
        if random_color:
          background_color = random.choice(background_colors)
        else:
          background_color = (255, 255, 255)
        bg = Image.new('RGB', img.size, background_color)
        bg.paste(img, mask=img.split()[-1])

        if image_name.endswith('.webp'):
            bg = bg.convert('RGB')
            bg.save(f'{train_data_dir}/{image_name.replace(".webp", ".jpg")}', "JPEG")
            os.remove(f'{train_data_dir}/{image_name}')
            print(f" Converted image: {image_name} to {image_name.replace('.webp', '.jpg')}")
        else:
            bg.save(f'{train_data_dir}/{image_name}', "PNG")
            print(f" Converted image: {image_name}")
    else:
        if image_name.endswith('.webp'):
            img.save(f'{train_data_dir}/{image_name.replace(".webp", ".jpg")}', "JPEG")
            os.remove(f'{train_data_dir}/{image_name}')
            print(f" Converted image: {image_name} to {image_name.replace('.webp', '.jpg')}")
        else:
            img.save(f'{train_data_dir}/{image_name}', "PNG")

num_batches = len(images) // batch_size + 1

if convert:
  with concurrent.futures.ThreadPoolExecutor() as executor:
      for i in tqdm(range(num_batches)):
          start = i * batch_size
          end = start + batch_size
          batch = images[start:end]
          executor.map(process_image, batch)

  print("All images have been converted")
## 4.2. Data Annotation
You can choose to train a model using caption. We're using [GIT: GenerativeImage2Text](https://huggingface.co/models?search=microsoft/git) for image captioning and [Waifu Diffusion 1.4 Tagger](https://huggingface.co/spaces/SmilingWolf/wd-v1-4-tags) for image tagging like danbooru.
- Use GIT Captioning for: `Images in General`
- Use Waifu Diffusion 1.4 Tagger V2 for: `Anime and manga-styled Images`

#@title ### 4.2.1. BLIP Captioning
#@markdown [BLIP](https://huggingface.co/spaces/Salesforce/BLIP) is a pre-training framework for unified vision-language understanding and generation, which achieves state-of-the-art results on a wide range of vision-language tasks.
#@markdown In short, it can be used as a tool for image captioning. Example: `astronaut riding a horse in space`. 
import os

os.chdir(finetune_dir)

batch_size = 8 #@param {type:'number'}
max_data_loader_n_workers = 2 #@param {type:'number'}
beam_search = True #@param {type:'boolean'}
min_length = 5 #@param {type:"slider", min:0, max:100, step:5.0}
max_length = 75 #@param {type:"slider", min:0, max:100, step:5.0}

!python make_captions.py \
  "{train_data_dir}" \
  --batch_size {batch_size} \
  {"--beam_search" if beam_search else ""} \
  --min_length {min_length} \
  --max_length {max_length} \
  --caption_extension .caption \
  --max_data_loader_n_workers {max_data_loader_n_workers}
#@title ### 4.2.2. Waifu Diffusion 1.4 Tagger V2
import os
%store -r

os.chdir(finetune_dir)

#@markdown [Waifu Diffusion 1.4 Tagger V2](https://huggingface.co/spaces/SmilingWolf/wd-v1-4-tags) is Danbooru-styled image classification developed by [SmilingWolf](https://github.com/SmilingWolf).  Can also be useful for general image tagging.
#@markdown Example: `1girl, solo, looking_at_viewer, short_hair, bangs, simple_background`. 
batch_size = 8 #@param {type:'number'}
max_data_loader_n_workers = 2 #@param {type:'number'}
model = "SmilingWolf/wd-v1-4-swinv2-tagger-v2" #@param ["SmilingWolf/wd-v1-4-swinv2-tagger-v2", "SmilingWolf/wd-v1-4-convnext-tagger-v2", "SmilingWolf/wd-v1-4-vit-tagger-v2"]
#@markdown Adjust threshold for better training results.
#@markdown - High threshold (e.g. `0.85`) for object/character training.
#@markdown - Low threshold (e.g. `0.35`) for general/style/environment training.
threshold = 0.35 #@param {type:"slider", min:0, max:1, step:0.05}

!python tag_images_by_wd14_tagger.py \
  "{train_data_dir}" \
  --batch_size {batch_size} \
  --repo_id {model} \
  --thresh {threshold} \
  --caption_extension .txt \
  --max_data_loader_n_workers {max_data_loader_n_workers}

#@title ### 4.2.3. Custom Caption/Tag (Optional)
import os
%store -r

os.chdir(root_dir)

#@markdown Add custom tags here.
extension = ".txt" #@param [".txt", ".caption"]
custom_tag = "" #@param {type:"string"}
#@markdown Enable to append custom tags at the end of lines.
append = False #@param {type:"boolean"}

#@markdown Prevent shuffling of custom tags with `keep_tokens`.
#@markdown `keep_tokens` overrides `append` by adding new tags to the first line.
keep_tokens = 1 #@param {type:"number"}

def add_tag(filename, tag, append):
    with open(filename, "r") as f:
        contents = f.read()
        	    	
    tag = ", ".join(tag.split())
    tag = tag.replace("_", " ")
    
    if tag in contents:
        return
        
    if not keep_tokens:
      contents = contents.rstrip() + ", " + tag if append else tag + ", " + contents
    else:
      contents = tag + ", " + contents
    
    with open(filename, "w") as f:
        f.write(contents)

if not any([filename.endswith("." + extension) for filename in os.listdir(train_data_dir)]):
    for filename in os.listdir(train_data_dir):
        if filename.endswith((".png", ".jpg", ".jpeg", ".webp", ".bmp")):
            open(os.path.join(train_data_dir, filename.split(".")[0] + "." + extension), "w").close()

tags = custom_tag.split()

if custom_tag:
  for filename in os.listdir(train_data_dir):
      if filename.endswith(extension):
          for tag in tags:
              add_tag(os.path.join(train_data_dir, filename), tag, append)

# V. Training Model


#@title ## 5.1. Folder Config
from google.colab import drive
from IPython.utils import capture  
%store -r

v2 = False #@param {type:"boolean"}
v_parameterization = False #@param {type:"boolean"}
project_name = "lartiguephoto" #@param {type:"string"}
if not project_name:
  project_name = "last"
pretrained_model_name_or_path = "/content/pretrained_model/Stable-Diffusion-v1-5.safetensors" #@param {type:"string"}
vae = "/content/vae/stablediffusion.vae.pt"  #@param {type:"string"}
#@markdown You need to specify parent folder and not where `train_data_dir` located
train_folder_directory = "/content/LoRA/train_data" #@param {'type':'string'}
reg_folder_directory = "/content/LoRA/reg_data" #@param {'type':'string'}
output_dir = "/content/LoRA/output" #@param {'type':'string'}
resume_path =""
inference_url = "https://raw.githubusercontent.com/Stability-AI/stablediffusion/main/configs/stable-diffusion/"

#@markdown This will ignore `output_dir` defined above, and changed to `/content/drive/MyDrive/LoRA/output` by default
output_to_drive = False #@param {'type':'boolean'}

if output_to_drive:
  output_dir = "/content/drive/MyDrive/LoRA/output"

  if not os.path.exists("/content/drive"):
    drive.mount('/content/drive')  

os.makedirs(output_dir, exist_ok=True)

folder_config = ["v2",
                  "v_parameterization",
                  "project_name",
                  "pretrained_model_name_or_path",
                  "vae",
                  "train_folder_directory",
                  "reg_folder_directory",
                  "output_dir",
                  "resume_path"]
with capture.capture_output() as cap:                  
  for config in folder_config:
    %store {config}
  %store "folder_config"
  del cap

if v2 and not v_parameterization:
  inference_url += "v2-inference.yaml"
if v2 and v_parameterization:
  inference_url += "v2-inference-v.yaml"

try:
  if v2:
    !wget -q --show-progress {inference_url} -O {output_dir}/{project_name}.yaml
    print("File successfully downloaded")
except:
  print("There was an error downloading the file. Please check the URL and try again.")

print("Project Name: ", project_name)
print("Model Version: Stable Diffusion V1.x") if not v2 else ""
print("Model Version: Stable Diffusion V2.x") if v2 and not v_parameterization else ""
print("Model Version: Stable Diffusion V2.x 768v") if v2 and v_parameterization else ""
print("Pretrained Model Path: ", pretrained_model_name_or_path) if pretrained_model_name_or_path else print("No Pretrained Model path specified.")
print("VAE Path: ", vae) if vae else print("No VAE path specified.")
print("Train Folder Directory: ", train_folder_directory)
print("Reg Folder Directory: ", reg_folder_directory) if reg_folder_directory else print("No Regularization Folder Path specified, training without reg_images instead.")
print("Output Path: ", output_dir)
print("Resume Path: ", resume_path) if resume_path else print("No resume path specified.")


#@title ## 5.2. LoRA and Optimizer Config
from IPython.utils import capture  

#@markdown ### LoRA Config:<br>
#@markdown Some people recommend setting the `network_dim` to a higher value.
network_dim = 160 #@param {'type':'number'}
#@markdown For weight scaling in LoRA, it is better to set `network_alpha` the same as `network_dim` unless you know what you're doing. A lower `network_alpha` requires a higher learning rate. For example, if `network_alpha = 1`, then `unet_lr = 1e-3`.
network_alpha = 160 #@param {'type':'number'}
network_module = "networks.lora"
#@markdown `network_weight` can be specified to resume training.
network_weight = "" #@param {'type':'string'}
#@markdown By default, both Text Encoder and U-Net LoRA modules are enabled. Use `network_train_on` to specify which module to train.
network_train_on = "both" #@param ['both','unet_only', 'text_encoder_only'] {'type':'string'}
#@markdown ### <br>Optimizer Config:<br>
#@markdown `AdamW8bit` was the old `--use_8bit_adam` . Use `DAdaptation` if you find it hard to set optimizer hyperparameter right.
optimizer_type = "AdamW8bit" #@param ["AdamW", "AdamW8bit", "Lion", "SGDNesterov", "SGDNesterov8bit", "DAdaptation", "AdaFactor"]
#@markdown Additional arguments for optimizer, e.g: `"decouple=True weight_decay=0.01 betas=0.9,0.999 ..."`
optimizer_args = "" #@param {'type':'string'}
#@markdown Set `unet_lr` to `1.0` if you use `DAdaptation` optimizer, as it's a [free learning rate](https://github.com/facebookresearch/dadaptation) algorithm. 
#@markdown However `text_encoder_lr = 1/2 * unet_lr` still applied, so you need to set `0.5` for `text_encoder_lr`.
#@markdown Also actually you don't need to specify `learning_rate` value if both `unet_lr` and `text_encoder_lr` are defined.
unet_lr = 1e-4 #@param {'type':'number'}
text_encoder_lr = 5e-5 #@param {'type':'number'}
lr_scheduler = "constant" #@param ["linear", "cosine", "cosine_with_restarts", "polynomial", "constant", "constant_with_warmup"] {allow-input: false}
lr_warmup_steps = 0 #@param {'type':'number'}
#@markdown You can define `num_cycles` value for `cosine_with_restarts` or `power` value for `polynomial` in the field below.
lr_scheduler_args = 1 #@param {'type':'number'}

lora_and_optimizer_config = ["network_dim",
                              "network_alpha",
                              "network_module",
                              "network_weight",
                              "optimizer_type", 
                              "optimizer_args", 
                              "unet_lr", 
                              "text_encoder_lr", 
                              "lr_scheduler", 
                              "lr_warmup_steps", 
                              "lr_scheduler_args"]
with capture.capture_output() as cap:   
  for config in lora_and_optimizer_config:
    %store {config}
  %store "lora_and_optimizer_config"
  del cap

if optimizer_type == "Lion":
  print("Installing Lion Pytorch...")
  !pip -q install lion-pytorch
if optimizer_type == "DAdaptation":
  print("Installing DAdaptation...")
  !pip -q install dadaptation

print("- LoRA Config:")
print("Loading network module:", network_module)
print(f"{network_module} dim set to:", network_dim)
print(f"{network_module} alpha set to:", network_alpha)
if not network_weight:
  print("No LoRA weight loaded.")
else:
  if os.path.exists(network_weight):
    print("Loading LoRA weight:", network_weight)
  else:
    print(f"{network_weight} does not exist.")
    network_weight =""
print("Enable LoRA for U-Net") if network_train_on == "both" or "unet_only" else ""
print("Enable LoRA for Text Encoder") if network_train_on == "both" or "text_encoder_only" else ""
print("Disable LoRA for U-Net") if network_train_on == "text_encoder_only" else ""
print("Disable LoRA for Text Encoder") if  network_train_on == "unet_only" else ""

print("- Optimizer Config:")
print(f"Using {optimizer_type} as Optimizer")
if optimizer_args:
  print(f"Optimizer Args :", optimizer_args)
print("UNet learning rate: ", unet_lr)
print("Text encoder learning rate: ", text_encoder_lr)
print("Learning rate warmup steps: ", lr_warmup_steps)
print("Learning rate Scheduler:", lr_scheduler)
if lr_scheduler == "cosine_with_restarts":
  print("- lr_scheduler_num_cycles: ", lr_scheduler_args)
elif lr_scheduler == "polynomial":
  print("- lr_scheduler_power: ", lr_scheduler_args)
from IPython.utils import capture
%store -r

#@title ## 5.3. Dataset Config
#@markdown Enable this option to train on non-square resolution, so you don't need to manually crop your dataset to `512x512` ever again.	
enable_bucket = True #@param {type:"boolean"}	
resolution = 512 #@param {type:"slider", min:512, max:1024, step:128}
bucket_reso_steps = 64 #@param {type:"slider", min:0, max:100, step:8}	
#@markdown By using `enable_bucket`, your dataset will automatically upscale or downscale to a certain resolution. You can ignore that and train with the original resolution instead by checking `bucket_no_upscale`. However, that doesn't mean your dataset will train higher than the provided resolution.	
bucket_no_upscale = False #@param{type:"boolean"}	
#@markdown This option is to convert your image to `latents` by processing the images with VAE before actually starting training. And then using that latent instead of the raw one for training.	
cache_latents = True #@param {type:"boolean"}	
#@markdown Enable this option for horizontal flip augmentation.	
flip_aug = False #@param {type:"boolean"}	
#@markdown Specify this if you want to train dreambooth with captions (`.caption`) or tags (`.txt`). Select `none` if you want to train with dreambooth token instead.	
caption_extension = ".caption" #@param ["none", ".txt", ".caption"]	
#@markdown You can ignore some tags or captions chosen at random when training your model. Specify `caption_dropout_every_n_epochs` to dropout caption every n epochs.	
caption_dropout_rate = 0 #@param {type:"slider", min:0, max:1, step:0.05}	
caption_dropout_every_n_epochs = 0 #@param {type:"number"}

# Absolute Value
min_bucket_reso = 320 if resolution > 640 else 256
max_bucket_reso = 1280 if resolution > 640 else 1024

dataset_config = ["enable_bucket",
                  "resolution",
                  "min_bucket_reso",
                  "max_bucket_reso",
                  "bucket_reso_steps",
                  "bucket_no_upscale",
                  "cache_latents",
                  "flip_aug",
                  "caption_extension",
                  "caption_dropout_rate",
                  "caption_dropout_every_n_epochs"]
with capture.capture_output() as cap: 
  for config in dataset_config:
    %store {config}
  %store "dataset_config"
  del cap

print("Bucketing and latents config:")
print("- Enable bucketing") if enable_bucket and not cache_latents else ""
print("- Enable bucketing and latents") if enable_bucket and cache_latents else ""
print("- Enable latents") if not enable_bucket and cache_latents else ""
print("- Max Train Resolution:", resolution)
print("- Resolution steps:", bucket_reso_steps) if enable_bucket else ""
print("- No Upscaling") if enable_bucket and bucket_no_upscale else ""
print("Augmentation Config:")
print("- Flip Horizontal Augmentation") if flip_aug else print("- none")
print("Caption Dropout Config:") if not caption_extension == "none" else ""
print("- Tag Dropout Rate:", caption_dropout_rate) if caption_extension == ".txt" else ""
print("- Caption Dropout Rate:", caption_dropout_rate) if caption_extension == ".caption" else ""
print(f"- Drop every {caption_dropout_every_n_epochs} epochs") if caption_dropout_every_n_epochs else ""
#@title ## 5.4. Start Training
from prettytable import PrettyTable
from IPython.utils import capture
import textwrap
import yaml
import os
%store -r

lowram = True #@param {type:"boolean"}
#@markdown Read [Diffusion With Offset Noise](https://www.crosslabs.org//blog/diffusion-with-offset-noise), in short, you can control and easily generating darker or light images by offset the noise when fine-tuning the model. Set to `0` by default, recommended value: `0.1`
noise_offset = 0 #@param {type:"number"}
max_train_type = "max_train_epochs" #@param ["max_train_steps", "max_train_epochs"]
max_train_type_value = 20 #@param {type:"number"}
train_batch_size = 6 #@param {type:"number"}
mixed_precision = "fp16" #@param ["no","fp16","bf16"] {allow-input: false}
save_precision = "fp16" #@param ["float", "fp16", "bf16"] {allow-input: false}
save_n_epochs_type = "save_every_n_epochs" #@param ["save_every_n_epochs", "save_n_epoch_ratio"] {allow-input: false}
save_n_epochs_type_value = 1 #@param {type:"number"}
save_model_as = "safetensors" #@param ["ckpt", "pt", "safetensors"] {allow-input: false}
max_token_length = 225 #@param {type:"number"}
clip_skip = 2 #@param {type:"number"}
gradient_checkpointing = False #@param {type:"boolean"}
gradient_accumulation_steps = 1 #@param {type:"number"}
seed = -1 #@param {type:"number"}
logging_dir = "/content/LoRA/logs"
additional_argument = "--shuffle_caption --xformers" #@param {type:"string"}
print_hyperparameter = True #@param {type:"boolean"}

# Absolute value
prior_loss_weight = 1.0
              
os.chdir(repo_dir)

train_command=f"""
accelerate launch --config_file={accelerate_config} --num_cpu_threads_per_process=8 train_network.py \
  {"--v2" if v2 else ""} \
  {"--v_parameterization" if v2 and v_parameterization else ""} \
  {"--output_name=" + project_name if project_name else ""} \
  --pretrained_model_name_or_path={pretrained_model_name_or_path} \
  {"--vae=" + vae if vae else ""} \
  --train_data_dir={train_folder_directory} \
  --reg_data_dir={reg_folder_directory} \
  --output_dir={output_dir} \
  {"--resume=" + resume_path if resume_path else ""} \
  \
  --network_dim={network_dim} \
  --network_alpha={network_alpha} \
  --network_module={network_module} \
  {"--network_weights=" + network_weight if network_weight else ""} \
  {"--network_train_unet_only" if network_train_on == "unet_only" else ""} \
  {"--network_train_text_encoder_only" if network_train_on == "text_encoder_only" else ""} \
  --optimizer_type={optimizer_type} \
  {"--optimizer_args=" + optimizer_args if optimizer_args else ""} \
  --learning_rate={unet_lr} \
  {"--unet_lr=" + format(unet_lr) if unet_lr else ""} \
  {"--text_encoder_lr=" + format(text_encoder_lr) if text_encoder_lr else ""} \
  --lr_scheduler={lr_scheduler} \
  {"--lr_warmup_steps=" + format(lr_warmup_steps) if lr_warmup_steps else ""} \
  {"--lr_scheduler_num_cycles=" + format(lr_scheduler_args) if lr_scheduler == "cosine_with_restarts" else ""} \
  {"--lr_scheduler_power=" + format(lr_scheduler_args) if lr_scheduler == "polynomial" else ""} \
  \
  {"--enable_bucket" if enable_bucket else ""} \
  --resolution={resolution} \
  {"--cache_latents" if cache_latents else ""} \
  {"--bucket_reso_steps=" + format(bucket_reso_steps) if enable_bucket else ""} \
  {"--bucket_no_upscale" if bucket_no_upscale and enable_bucket else ""} \
  {"--min_bucket_reso=" + format(min_bucket_reso) if enable_bucket else ""} \
  {"--max_bucket_reso=" + format(max_bucket_reso) if enable_bucket else ""} \
  {"--caption_extension=" + caption_extension if not caption_extension == "none" else ""} \
  {"--keep_tokens=" + format(keep_tokens) if "keep_tokens" in locals() or "keep_tokens" in globals() else ""} \
  {"--caption_dropout_rate=" + format(caption_dropout_rate) if caption_extension == ".caption" and caption_dropout_rate else ""} \
  {"--caption_tag_dropout_rate=" + format(caption_dropout_rate) if caption_extension == ".txt" and caption_dropout_rate else ""} \
  {"--caption_dropout_every_n_epochs=" + format(caption_dropout_every_n_epochs) if caption_dropout_every_n_epochs else ""} \
  \
  --prior_loss_weight={prior_loss_weight} \
  {"--lowram" if lowram else ""} \
  {"--noise_offset=" + format(noise_offset) if noise_offset > 0 else ""} \
  --train_batch_size={train_batch_size} \
  {"--max_train_epochs=" + format(max_train_type_value) if max_train_type == "max_train_epochs" else ""} \
  {"--max_train_steps=" + format(max_train_type_value) if max_train_type == "max_train_steps" else ""} \
  --mixed_precision={mixed_precision} \
  --save_precision={save_precision} \
  {"--save_every_n_epochs=" + format(save_n_epochs_type_value) if save_n_epochs_type=="save_every_n_epochs" else ""} \
  {"--save_n_epoch_ratio=" + format(save_n_epochs_type_value) if save_n_epochs_type=="save_n_epoch_ratio" else ""} \
  --save_model_as={save_model_as} \
  --max_token_length={max_token_length} \
  {"--seed=" + format(seed) if seed > 0 else ""} \
  {"--gradient_checkpointing" if gradient_checkpointing else ""} \
  {"--gradient_accumulation_steps=" + format(gradient_accumulation_steps) } \
  {"--clip_skip=" + format(clip_skip) if not v2 else ""} \
  --logging_dir={logging_dir} \
  --log_prefix={project_name} \
  {additional_argument}
  """
training_config= ["prior_loss_weight",
                  "lowram",
                  "noise_offset",
                  "max_train_type",
                  "max_train_type_value",
                  "train_batch_size",
                  "mixed_precision",
                  "save_precision",
                  "save_n_epochs_type",
                  "save_n_epochs_type_value",
                  "save_model_as",
                  "max_token_length",
                  "clip_skip",
                  "gradient_checkpointing",
                  "gradient_accumulation_steps",
                  "seed",
                  "logging_dir",
                  "additional_argument"]
with capture.capture_output() as cap:                  
  for config in training_config:
    %store {config}
  %store "training_config"
  del cap

if print_hyperparameter:
  for debug_params in ["folder_config",
                       "dataset_config",
                       "lora_and_optimizer_config",
                       "training_config"]:
    table = PrettyTable()
    table.field_names = ["Hyperparameter", "Value"]
    for params in eval(debug_params):
        if params:
            if globals()[params] == "":
                value = "False"
            else:
                value = globals()[params]
            table.add_row([params, value])
    table.align = "l"
    print(table)

arg_list = train_command.split()
mod_train_command = {'command': arg_list}
    
with open(os.path.join(training_dir,'dreambooth_lora_cmd.yaml'), 'w') as f:
  yaml.dump(mod_train_command, f)

f = open("./train.sh", "w")
f.write(train_command)
f.close()
!chmod +x ./train.sh
!./train.sh
# VI. Testing
#@title ## 6.1. Interrogating LoRA Weights
#@markdown Now you can check if your LoRA trained properly. 

#@markdown  If you used `clip_skip = 2` during training, the values of `lora_te_text_model_encoder_layers_11_*` will be `0.0`, this is normal. These layers are not trained at this value of `Clip Skip`.
network_weight = "" #@param {'type':'string'}
no_verbose = True #@param {type:"boolean"}

import os
import torch
import json
from safetensors.torch import load_file
from safetensors.torch import safe_open
import library.model_util as model_util

print("Loading LoRA weight:", network_weight)

def main(file, verbose:bool):
  if not verbose:
    sd = load_file(file) if os.path.splitext(file)[1] == '.safetensors' else torch.load(file, map_location='cuda')
    values = []

    keys = list(sd.keys())
    for key in keys:
      if 'lora_up' in key or 'lora_down' in key:
        values.append((key, sd[key]))
    print(f"number of LoRA modules: {len(values)}")

    for key, value in values:
      value = value.to(torch.float32)
      print(f"{key},{torch.mean(torch.abs(value))},{torch.min(torch.abs(value))}")
  
  if model_util.is_safetensors(file):
      with safe_open(file, framework="pt") as f:
          metadata = f.metadata()
      if metadata is not None:
        if not verbose:
          metadata["ss_bucket_info"] = json.loads(metadata["ss_bucket_info"].replace("\\", ""))
          metadata["ss_tag_frequency"] = json.loads(metadata["ss_tag_frequency"].replace("\\", ""))
        metadata["ss_dataset_dirs"] = json.loads(metadata["ss_dataset_dirs"].replace("\\", ""))
        metadata["ss_reg_dataset_dirs"] = json.loads(metadata["ss_reg_dataset_dirs"].replace("\\", ""))
        print(f"\nLoad metadata for: {file}")
        print(json.dumps(metadata, indent=4))
  else:
      print("No metadata saved, your model is not in safetensors format")

if __name__ == '__main__':
  main(network_weight, no_verbose)
#@title ## 6.2. Inference
%store -r

#@markdown ### LoRA Config
network_weight = "" #@param {'type':'string'}
network_module = "networks.lora"
network_mul = 0.7 #@param {type:"slider", min:-1, max:2, step:0.05}

#@markdown ### <br> General Config
v2 = False #@param {type:"boolean"}
v_parameterization = False #@param {type:"boolean"}
instance_prompt = "" #@param {type: "string"}
prompt = "masterpiece, best quality, 1girl, aqua eyes, baseball cap, blonde hair, closed mouth, earrings, green background, hat, hoop earrings, jewelry, looking at viewer, shirt, short hair, simple background, solo, upper body, yellow shirt" #@param {type: "string"}
negative = "lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry" #@param {type: "string"}
model = "/content/pretrained_model/Anything-v3-1.safetensors" #@param {type: "string"}
vae = "" #@param {type: "string"}
outdir = "/content/tmp" #@param {type: "string"}
scale = 7 #@param {type: "slider", min: 1, max: 40}
sampler = "ddim" #@param ["ddim", "pndm", "lms", "euler", "euler_a", "heun", "dpm_2", "dpm_2_a", "dpmsolver","dpmsolver++", "dpmsingle", "k_lms", "k_euler", "k_euler_a", "k_dpm_2", "k_dpm_2_a"]
steps = 28 #@param {type: "slider", min: 1, max: 100}
precision = "fp16" #@param ["fp16", "bf16"] {allow-input: false}
width = 512 #@param {type: "integer"}
height = 768 #@param {type: "integer"}
images_per_prompt = 4 #@param {type: "integer"}
batch_size = 4 #@param {type: "integer"}
clip_skip = 2 #@param {type: "slider", min: 1, max: 40}
seed = -1 #@param {type: "integer"}

final_prompt = f"{instance_prompt}, {prompt} --n {negative}" if instance_prompt else f"{prompt} --n {negative}"

os.chdir(repo_dir)

!python gen_img_diffusers.py \
  {"--v2" if v2 else ""} \
  {"--v_parameterization" if v2 and v_parameterization else ""} \
  {"--network_module=networks.lora" if network_weight else ""} \
  {"--network_weight=" + network_weight if network_weight else ""} \
  {"--network_mul=" + format(network_mul) if network_weight else ""} \
  --ckpt={model} \
  --outdir={outdir} \
  --xformers \
  {"--vae=" + vae if vae else ""} \
  --{precision} \
  --W={width} \
  --H={height} \
  {"--seed=" + format(seed) if seed > 0 else ""} \
  --scale={scale} \
  --sampler={sampler} \
  --steps={steps} \
  --max_embeddings_multiples=3 \
  --batch_size={batch_size} \
  --images_per_prompt={images_per_prompt} \
  {"--clip_skip=" + format(clip_skip) if not v2 else ""} \
  --prompt="{final_prompt}"


#@title ## 6.3. Visualize loss graph (Optional)
training_logs_path = "/content/LoRA/logs" #@param {type : "string"}

%cd /content/kohya-trainer
%load_ext tensorboard
%tensorboard --logdir {training_logs_path}
# VII. Extras
#@title ## 7.1. Compressing model or dataset
import os
import zipfile
import shutil

zip_module = "zipfile" #@param ["zipfile", "shutil", "pyminizip", "zip"]
directory_to_zip = '/content/LoRA/output' #@param {type: "string"}
output_filename = f'/content/{project_name}.zip' #@param {type: "string"}
password = "" #@param {type: "string"}

if zip_module == "zipfile":
    with zipfile.ZipFile(output_filename, 'w') as zip:
        for directory_to_zip, dirs, files in os.walk(directory_to_zip):
            for file in files:
                zip.write(os.path.join(directory_to_zip, file))
elif zip_module == "shutil":
    shutil.make_archive(output_filename, 'zip', directory_to_zip)
elif zip_module == "pyminizip":
    !pip install pyminizip
    import pyminizip
    for root, dirs, files in os.walk(directory_to_zip):
        for file in files:
            pyminizip.compress(os.path.join(root, file), "", os.path.join("*",output_filename), password, 5)
elif zip_module == "zip":
    !zip -rv -q -j {output_filename} {directory_to_zip}
# VIII. Deployment
#@title ## 8.1. Upload Config
from huggingface_hub import login
from huggingface_hub import HfApi
from huggingface_hub.utils import validate_repo_id, HfHubHTTPError

#@markdown Login to Huggingface Hub 
#@markdown > Get **your** huggingface `WRITE` token [here](https://huggingface.co/settings/tokens)
write_token = "" #@param {type:"string"}
login(write_token, add_to_git_credential=True)

api = HfApi()
user = api.whoami(write_token)

#@markdown Fill this if you want to upload to your organization, or just leave it empty.

orgs_name = "" #@param{type:"string"}

#@markdown If your model/dataset repo didn't exist, it will automatically create your repo.
model_name = "your-model-name" #@param{type:"string"}
dataset_name = "your-dataset-name" #@param{type:"string"}
make_this_model_private = False #@param{type:"boolean"}

if orgs_name == "":
  model_repo = user['name']+"/"+model_name.strip()
  datasets_repo = user['name']+"/"+dataset_name.strip()
else:
  model_repo = orgs_name+"/"+model_name.strip()
  datasets_repo = orgs_name+"/"+dataset_name.strip()

if model_name:
  try:
      validate_repo_id(model_repo)
      api.create_repo(repo_id=model_repo, 
                      private=make_this_model_private)
      print("Model Repo didn't exists, creating repo")
      print("Model Repo: ",model_repo,"created!\n")

  except HfHubHTTPError as e:
      print(f"Model Repo: {model_repo} exists, skipping create repo\n")

if dataset_name:
  try:
      validate_repo_id(datasets_repo)
      api.create_repo(repo_id=datasets_repo,
                      repo_type="dataset",
                      private=make_this_model_private)
      print("Dataset Repo didn't exists, creating repo")
      print("Dataset Repo",datasets_repo,"created!\n")

  except HfHubHTTPError as e:
      print(f"Dataset repo: {datasets_repo} exists, skipping create repo\n")

## 8.2. Upload with Huggingface Hub
#@title ### 8.2.1. Upload LoRA 
from huggingface_hub import HfApi
from pathlib import Path
%store -r

api = HfApi()

#@markdown This will be uploaded to model repo
model_path = "/content/LoRA/output" #@param {type :"string"}
path_in_repo = "" #@param {type :"string"}

#@markdown Other Information
commit_message = "" #@param {type :"string"}

if not commit_message:
  commit_message = "feat: upload "+project_name+" lora model"
  
def upload_model(model_paths, is_folder :bool):
  path_obj = Path(model_paths)
  trained_model = path_obj.parts[-1]
  
  if path_in_repo:
    trained_model = path_in_repo
    
  if is_folder:
    print(f"Uploading {trained_model} to https://huggingface.co/"+model_repo)
    print(f"Please wait...")
    
    api.upload_folder(
        folder_path=model_paths,
        path_in_repo=trained_model,
        repo_id=model_repo,
        commit_message=commit_message,
        ignore_patterns=".ipynb_checkpoints"
        )
    print(f"Upload success, located at https://huggingface.co/"+model_repo+"/tree/main\n")
  else: 
    print(f"Uploading {trained_model} to https://huggingface.co/"+model_repo)
    print(f"Please wait...")
            
    api.upload_file(
        path_or_fileobj=model_paths,
        path_in_repo=trained_model,
        repo_id=model_repo,
        commit_message=commit_message,
        )
        
    print(f"Upload success, located at https://huggingface.co/"+model_repo+"/blob/main/"+trained_model+"\n")
      
def upload():
    if model_path.endswith((".ckpt", ".safetensors", ".pt")):
      upload_model(model_path, False)
    else:
      upload_model(model_path, True)

upload()
#@title ### 8.2.2. Upload Dataset
from huggingface_hub import HfApi
from pathlib import Path
import shutil
import zipfile
import os

api = HfApi()

#@markdown This will be compressed to zip and  uploaded to datasets repo, leave it empty if not necessary
train_data_path = "/content/LoRA/train_data" #@param {type :"string"}
#@markdown `Nerd stuff, only if you want to save training logs`
logs_path = "/content/LoRA/logs" #@param {type :"string"}

if project_name:
  tmp_dataset = "/content/LoRA/"+project_name+"_dataset"
else:
  tmp_dataset = "/content/LoRA/tmp_dataset"

tmp_train_data = tmp_dataset + "/train_data"
dataset_zip = tmp_dataset + ".zip"

#@markdown Other Information
commit_message = "" #@param {type :"string"}

if not commit_message:
  commit_message = "feat: upload "+project_name+" dataset and logs"

os.makedirs(tmp_dataset, exist_ok=True)
os.makedirs(tmp_train_data, exist_ok=True)

def upload_dataset(dataset_paths, is_zip : bool):
  path_obj = Path(dataset_paths)
  dataset_name = path_obj.parts[-1]

  if is_zip:
    print(f"Uploading {dataset_name} to https://huggingface.co/datasets/"+datasets_repo)
    print(f"Please wait...")

    api.upload_file(
        path_or_fileobj=dataset_paths,
        path_in_repo=dataset_name,
        repo_id=datasets_repo,
        repo_type="dataset",
        commit_message=commit_message,
    )
    print(f"Upload success, located at https://huggingface.co/datasets/"+datasets_repo+"/blob/main/"+dataset_name+"\n")
  else:
    print(f"Uploading {dataset_name} to https://huggingface.co/datasets/"+datasets_repo)
    print(f"Please wait...")

    api.upload_folder(
        folder_path=dataset_paths,
        path_in_repo=dataset_name,
        repo_id=datasets_repo,
        repo_type="dataset",
        commit_message=commit_message,
        ignore_patterns=".ipynb_checkpoints",
    )
    print(f"Upload success, located at https://huggingface.co/datasets/"+datasets_repo+"/tree/main/"+dataset_name+"\n")
  
def zip_file(tmp):
    zipfiles = tmp + ".zip" 
    with zipfile.ZipFile(zipfiles, 'w') as zip:
      for tmp, dirs, files in os.walk(tmp):
          for file in files:
              zip.write(os.path.join(tmp, file))

def move(src_path, dst_path, is_metadata: bool):
  files_to_move = ["meta_cap.json", \
                   "meta_cap_dd.json", \
                   "meta_lat.json", \
                   "meta_clean.json", \
                   "meta_final.json"]

  if os.path.exists(src_path):
    shutil.move(src_path, dst_path)

  if is_metadata:
    parent_meta_path = os.path.dirname(src_path)

    for filename in os.listdir(parent_meta_path):
      file_path = os.path.join(parent_meta_path, filename)
      if filename in files_to_move:
        shutil.move(file_path, dst_path)

def upload():
  if train_data_path:
    move(train_data_path, tmp_train_data, False)
    zip_file(tmp_dataset)
    upload_dataset(dataset_zip, True)
    os.remove(dataset_zip)
  if logs_path:
    upload_dataset(logs_path, False)

upload()
## 8.3. Upload with GIT (Alternative)
#@title ### 8.3.1. Clone Repository

clone_model = True #@param {'type': 'boolean'}
clone_dataset = True #@param {'type': 'boolean'}

!git lfs install --skip-smudge
!export GIT_LFS_SKIP_SMUDGE=1

if clone_model:
  !git clone https://huggingface.co/{model_repo} /content/{model_name}
  
if clone_dataset:
  !git clone https://huggingface.co/datasets/{datasets_repo} /content/{dataset_name}
#@title ### 8.3.2. Commit using Git 
import os

os.chdir(root_dir)

#@markdown Choose which repo you want to commit
commit_model = True #@param {'type': 'boolean'}
commit_dataset = True #@param {'type': 'boolean'}
#@markdown Other Information
commit_message = "" #@param {type :"string"}

if not commit_message:
  commit_message = "feat: upload "+project_name+" lora model and dataset"

!git config --global user.email "example@mail.com"
!git config --global user.name "example"

def commit(repo_folder, commit_message):
  os.chdir(os.path.join(root_dir, repo_folder))
  !git lfs install
  !huggingface-cli lfs-enable-largefiles .
  !git add .
  !git commit -m "{commit_message}"
  !git push

commit(model_name, commit_message)
commit(dataset_name, commit_message)